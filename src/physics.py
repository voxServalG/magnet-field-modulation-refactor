import numpy as np

# Physical constants
MU_0 = 4 * np.pi * 1e-7  # Vacuum permeability (T*m/A)

def biot_savart_wire_to_points(wire_start: np.ndarray, 
                               wire_end: np.ndarray, 
                               target_points: np.ndarray,
                               current_I: float) -> np.ndarray:
    '''
    Calculates the magnetic field vector generated by a finite straight wire segment at multiple target points.
    
    This function implements the vectorized Biot-Savart Law.

    Mathematical Formula:
    ---------------------
    $$ \vec{B} = \frac{\mu_0 I}{4\pi d} (\cos\theta_1 - \cos\theta_2) \hat{e} $$
    
    Args:
        wire_start (np.ndarray): Start point of the wire segment [x, y, z]. Shape (3,).
        wire_end (np.ndarray): End point of the wire segment [x, y, z]. Shape (3,).
        target_points (np.ndarray): Coordinates of M target points. Shape (M, 3).
        current_I (float): Current magnitude in Amperes.

    Returns:
        np.ndarray: Magnetic field vectors at each target point. Shape (M, 3), units in Tesla.

    Raises:
        ValueError: If input shapes are inconsistent.
    '''
    # Input validation and standardization
    wire_start = np.asarray(wire_start)
    wire_end = np.asarray(wire_end)
    target_points = np.asarray(target_points)

    if wire_start.shape != (3,) or wire_end.shape != (3,):
        raise ValueError("Wire start and end points must be (3,) vectors.")
    if target_points.ndim != 2 or target_points.shape[1] != 3:
        raise ValueError("Target points must be an (M, 3) array.")

    # Vector representing the wire segment
    vec_L = wire_end - wire_start            # Shape: (3,)
    L_norm = np.linalg.norm(vec_L)
    
    # Handle zero-length wire case
    if L_norm < 1e-12:
        return np.zeros_like(target_points)

    # Vectors from wire ends to target points
    vec_r1 = target_points - wire_start      # Shape: (M, 3)
    vec_r2 = target_points - wire_end        # Shape: (M, 3)

    # Distances
    norm_r1 = np.linalg.norm(vec_r1, axis=1) # Shape: (M,)
    norm_r2 = np.linalg.norm(vec_r2, axis=1) # Shape: (M,)

    # Cross product for B-field direction: vec_L x vec_r1
    cross_prod = np.cross(vec_L, vec_r1)     # Shape: (M, 3)
    norm_cross = np.linalg.norm(cross_prod, axis=1) # Shape: (M,)

    # Create mask for valid points (avoid division by zero for points on the wire)
    valid_mask = norm_cross > 1e-12
    B_vectors = np.zeros_like(target_points)

    if not np.any(valid_mask):
        return B_vectors

    # Calculate angle terms using dot products
    # cos_theta = dot(L, r) / (|L| * |r|)
    dot_L_r1 = np.sum(vec_L * vec_r1, axis=1) # Shape: (M,)
    dot_L_r2 = np.sum(vec_L * vec_r2, axis=1) # Shape: (M,)
    
    term1 = dot_L_r1 / (L_norm * norm_r1)
    term2 = dot_L_r2 / (L_norm * norm_r2)
    
    # Biot-Savart scalar magnitude factor
    # Note: 1/d = L_norm / norm_cross
    scalar_factor = (MU_0 * current_I / (4 * np.pi)) * (L_norm / norm_cross[valid_mask]) * (term1[valid_mask] - term2[valid_mask])
    
    # Unit direction vector
    unit_direction = cross_prod[valid_mask] / norm_cross[valid_mask][:, np.newaxis]
    
    # Combine magnitude and direction
    B_vectors[valid_mask] = scalar_factor[:, np.newaxis] * unit_direction

    return B_vectors


def get_mirror_positions(wire_start: np.ndarray, 
                         wire_end: np.ndarray, 
                         shield_dims: tuple[float, float, float] = (0.95, 0.95, 0.8)) -> list[tuple[np.ndarray, np.ndarray]]:
    '''
    Generates coordinates for the original wire segment and its mirror images.
    
    Simulates a magnetic shield by creating a 3x3x3 grid of current sources based on the 
    method of images.

    Args:
        wire_start (np.ndarray): Original wire start coordinates [x, y, z].
        wire_end (np.ndarray): Original wire end coordinates [x, y, z].
        shield_dims (tuple, optional): Dimensions of the shielding room (x1, y1, z1). Defaults to (0.95, 0.95, 0.8).

    Returns:
        list[tuple[np.ndarray, np.ndarray]]: A list of tuples, where each tuple contains 
        (start_point, end_point) for a mirror segment.
    '''
    x1, y1, z1 = shield_dims
    mirrors = []
    
    # Iterate through mirror indices corresponding to x, y, z reflections (-1, 0, 1)
    for i in [-1, 0, 1]:
        for j in [-1, 0, 1]:
            for k in [-1, 0, 1]:
                # Calculate reflection parity
                parity_x = (-1)**i
                parity_y = (-1)**j
                parity_z = (-1)**k
                
                # Calculate mirror coordinates
                start_x = 2 * i * x1 + wire_start[0] * parity_x
                start_y = 2 * j * y1 + wire_start[1] * parity_y
                start_z = 2 * k * z1 + wire_start[2] * parity_z
                
                end_x = 2 * i * x1 + wire_end[0] * parity_x
                end_y = 2 * j * y1 + wire_end[1] * parity_y
                end_z = 2 * k * z1 + wire_end[2] * parity_z
                
                p_start = np.array([start_x, start_y, start_z])
                p_end = np.array([end_x, end_y, end_z])
                
                mirrors.append((p_start, p_end))
                
    return mirrors


def calculate_field_from_coils(coils_3d: list[tuple[np.ndarray, np.ndarray, float, float]], 
                               target_points: np.ndarray,
                               current_I: float = 1.0,
                               use_shielding: bool = True) -> np.ndarray:
    '''
    Calculates the total magnetic field at target points generated by the entire coil system.

    Args:
        coils_3d: List of (top_loop, bottom_loop, I_top, I_bottom).
        target_points: (M, 3) coordinates.
        current_I: Global scale factor for current (default 1.0).
        use_shielding: If True, includes mirror currents.

    Returns:
        np.ndarray: Total magnetic field B. Shape (M, 3).
    '''
    total_B = np.zeros_like(target_points)
    
    for top_loop, bottom_loop, i_top_raw, i_bot_raw in coils_3d:
        
        # Combine global scale with individual loop currents
        loops_to_process = [
            (top_loop, i_top_raw * current_I),
            (bottom_loop, i_bot_raw * current_I) 
        ]
        
        for loop_coords, loop_current in loops_to_process:
            num_points = len(loop_coords)
            if num_points < 2:
                continue
                
            for k in range(num_points - 1):
                p_start = loop_coords[k]
                p_end = loop_coords[k+1]
                
                if use_shielding:
                    segments = get_mirror_positions(p_start, p_end)
                else:
                    segments = [(p_start, p_end)]
                
                for m_start, m_end in segments:
                    b_chunk = biot_savart_wire_to_points(m_start, m_end, target_points, loop_current)
                    total_B += b_chunk

    return total_B