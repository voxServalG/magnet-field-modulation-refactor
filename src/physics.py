import numpy as np
try:
    from numba import njit, prange
    HAS_NUMBA = True
except ImportError:
    HAS_NUMBA = False
    # Mock njit and prange for environments without numba
    def njit(*args, **kwargs):
        def decorator(f): return f
        return decorator
    prange = range

# Physical constants
MU_0 = 4 * np.pi * 1e-7  # Vacuum permeability (T*m/A)

@njit(fastmath=True, parallel=True)
def _biot_savart_kernel(starts, ends, currents, targets):
    '''
    High-performance Numba-jitted kernel for Biot-Savart Law.
    Iterates over target points in parallel and loops over all segments.
    '''
    M = targets.shape[0]
    N = starts.shape[0]
    B = np.zeros((M, 3))
    
    # Pre-factor (mu0 / 4pi) = 1e-7
    factor = 1e-7

    for i in prange(M):
        tx = targets[i, 0]
        ty = targets[i, 1]
        tz = targets[i, 2]
        
        sum_bx = 0.0
        sum_by = 0.0
        sum_bz = 0.0
        
        for j in range(N):
            sx, sy, sz = starts[j, 0], starts[j, 1], starts[j, 2]
            ex, ey, ez = ends[j, 0], ends[j, 1], ends[j, 2]
            curr = currents[j]
            
            # vec_L = end - start
            lx = ex - sx
            ly = ey - sy
            lz = ez - sz
            l_norm_sq = lx*lx + ly*ly + lz*lz
            l_norm = np.sqrt(l_norm_sq)
            
            if l_norm < 1e-12:
                continue
            
            # vec_r1 = target - start
            r1x, r1y, r1z = tx - sx, ty - sy, tz - sz
            # vec_r2 = target - end
            r2x, r2y, r2z = tx - ex, ty - ey, tz - ez
            
            nr1 = np.sqrt(r1x*r1x + r1y*r1y + r1z*r1z)
            nr2 = np.sqrt(r2x*r2x + r2y*r2y + r2z*r2z)
            
            # Cross product L x r1
            cx = ly * r1z - lz * r1y
            cy = lz * r1x - lx * r1z
            cz = lx * r1y - ly * r1x
            
            n_cross_sq = cx*cx + cy*cy + cz*cz
            
            if n_cross_sq < 1e-24: # Equivalent to 1e-12 norm
                continue
                
            # dot_L_r1, dot_L_r2
            dot1 = lx * r1x + ly * r1y + lz * r1z
            dot2 = lx * r2x + ly * r2y + lz * r2z
            
            term1 = dot1 / (l_norm * nr1)
            term2 = dot2 / (l_norm * nr2)
            
            # Scalar magnitude: (mu0*I / 4pi) * (L_norm / norm_cross^2) * (term1 - term2)
            scalar = (factor * curr * l_norm / n_cross_sq) * (term1 - term2)
            
            sum_bx += scalar * cx
            sum_by += scalar * cy
            sum_bz += scalar * cz
            
        B[i, 0] = sum_bx
        B[i, 1] = sum_by
        B[i, 2] = sum_bz
        
    return B

def biot_savart_wire_to_points(wire_start: np.ndarray, 
                               wire_end: np.ndarray, 
                               target_points: np.ndarray,
                               current_I: float) -> np.ndarray:
    '''
    Calculates the magnetic field vector generated by a finite straight wire segment at multiple target points.
    
    This function implements the vectorized Biot-Savart Law.
    '''
    # For a single wire, we still use the JIT kernel but with N=1
    starts = np.expand_dims(np.asarray(wire_start), 0)
    ends = np.expand_dims(np.asarray(wire_end), 0)
    currents = np.array([current_I])
    return _biot_savart_kernel(starts, ends, currents, target_points)


def get_mirror_positions(wire_start: np.ndarray, 
                         wire_end: np.ndarray, 
                         shield_dims: tuple[float, float, float] = (0.95, 0.95, 0.8)) -> list[tuple[np.ndarray, np.ndarray, float]]:
    '''
    Generates coordinates for the original wire segment and its mirror images, 
    including a current scaling factor for magnetic mirrors (Mu-metal).
    
    For Mu-metal (magnetic) mirrors, the image current must be in-phase. 
    Since a geometric reflection flips the chirality (sign), we must multiply 
    by the parity product to restore the positive phase.
    '''
    x1, y1, z1 = shield_dims
    mirrors = []
    
    for i in [-1, 0, 1]:
        for j in [-1, 0, 1]:
            for k in [-1, 0, 1]:
                # Calculate reflection parity
                parity_x = (-1)**abs(i) if i != 0 else 1
                parity_y = (-1)**abs(j) if j != 0 else 1
                parity_z = (-1)**abs(k) if k != 0 else 1
                
                # For magnetic mirrors, we want a 'Positive Image'.
                # Geometric flip (single axis) is naturally 'Negative' (Anti-mirror).
                # So we multiply by the parity product to flip it back.
                # 1 flip: scale = -1. 2 flips: scale = 1. 3 flips: scale = -1.
                # Note: original segment (0,0,0) has parity product 1.
                p_prod = 1
                if i != 0: p_prod *= -1
                if j != 0: p_prod *= -1
                if k != 0: p_prod *= -1
                
                # Mirror coordinates (Center-out logic)
                # If i=1, reflection plane is at x=x1. Mirror is at 2*x1 - x.
                # If i=-1, reflection plane is at x=-x1. Mirror is at -2*x1 - x.
                start_x = 2 * i * x1 + wire_start[0] * parity_x
                start_y = 2 * j * y1 + wire_start[1] * parity_y
                start_z = 2 * k * z1 + wire_start[2] * parity_z
                
                end_x = 2 * i * x1 + wire_end[0] * parity_x
                end_y = 2 * j * y1 + wire_end[1] * parity_y
                end_z = 2 * k * z1 + wire_end[2] * parity_z
                
                p_start = np.array([start_x, start_y, start_z])
                p_end = np.array([end_x, end_y, end_z])
                
                mirrors.append((p_start, p_end, float(p_prod)))
                
    return mirrors


def calculate_field_from_coils(coils_3d: list[tuple[np.ndarray, np.ndarray, float, float]], 
                               target_points: np.ndarray,
                               current_I: float = 1.0,
                               use_shielding: bool = True,
                               shield_dims: tuple[float, float, float] = (0.95, 0.95, 0.8),
                               show_progress: bool = False) -> np.ndarray:
    '''
    Calculates the total magnetic field at target points generated by the entire coil system.
    Uses Numba-accelerated kernel for performance.
    '''
    target_points = np.asarray(target_points)
    
    all_starts = []
    all_ends = []
    all_currents = []

    # 1. Flatten all coils and their mirrors into three simple arrays
    for idx, (top_loop, bottom_loop, i_top_raw, i_bot_raw) in enumerate(coils_3d):
        loops_to_process = [
            (top_loop, i_top_raw * current_I),
            (bottom_loop, i_bot_raw * current_I) 
        ]
        
        for loop_coords, loop_current in loops_to_process:
            num_pts = len(loop_coords)
            if num_pts < 2:
                continue
                
            for k in range(num_pts - 1):
                p_start = loop_coords[k]
                p_end = loop_coords[k+1]
                
                if use_shielding:
                    segments = get_mirror_positions(p_start, p_end, shield_dims=shield_dims)
                else:
                    segments = [(p_start, p_end, 1.0)]
                
                for s, e, scale in segments:
                    all_starts.append(s)
                    all_ends.append(e)
                    all_currents.append(loop_current * scale)

    if not all_starts:
        return np.zeros_like(target_points)

    # 2. Convert to numpy arrays for Numba
    starts_arr = np.array(all_starts)
    ends_arr = np.array(all_ends)
    currents_arr = np.array(all_currents)

    # 3. Call the JIT-accelerated kernel
    if show_progress:
        print(f"    -> Dispatching {len(starts_arr)} segments to JIT kernel...")
        
    total_B = _biot_savart_kernel(starts_arr, ends_arr, currents_arr, target_points)

    return total_B